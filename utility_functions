#  open bash in docker
function dbash() {
    ( docker exec -it $* bash )
}

# open sh in docker
function dsh() {
    ( docker exec -it $* sh )
}

# see docker logs
function dlog() {
   ( docker logs $*)
}

# see k8s secret
function see() {
    eval "$* -o json | jq '.data | map_values(@base64d)'"
}

repeat_cmd() {
  local GREEN="\033[1;32m"
  local YELLOW="\033[1;33m"
  local RED="\033[1;31m"
  local RESET="\033[0m"

  while true; do
    "$@"
    local exit_code=$?

    echo -e ""
    echo -e "${YELLOW}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"
    echo -e "${RED}Command exited with code ${exit_code}.${RESET}"
    echo -e "${GREEN}Restarting in 1 second...${RESET}"
    echo -e "${YELLOW}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${RESET}"

    sleep 1
  done
}


# K8s context switcher with gum (brew install gum)
kks() {
  # 1. Check gum is installed
  if ! command -v gum &>/dev/null; then
    echo "Error: gum is not installed. Run: brew install gum"
    return 1
  fi

  # Push content to bottom of terminal
  printf '\n%.0s' $(seq 1 $(($(tput lines) - 12)))

  # 2. Get and display current context
  local current=$(kubectl config current-context 2>/dev/null)
  gum style \
    --border rounded \
    --border-foreground 212 \
    --padding "0 1" \
    --margin "0 0 1 0" \
    "ðŸŽ¯ Current: ${current:-none}"

  # 3. Get available contexts
  local contexts=("${(@f)$(kubectl config get-contexts -o name 2>/dev/null)}")

  if [[ ${#contexts[@]} -eq 0 ]]; then
    gum style --foreground 196 "No contexts found"
    return 1
  fi

  # 4. Show selection menu with gum choose
  #    Put current context at top with checkmark
  local display_contexts=()
  if [[ -n "$current" ]]; then
    display_contexts+=("$current âœ“")
  fi
  for ctx in "${contexts[@]}"; do
    if [[ "$ctx" != "$current" ]]; then
      display_contexts+=("$ctx")
    fi
  done

  local selected=$(printf '%s\n' "${display_contexts[@]}" | gum filter \
    --indicator="â†’" \
    --reverse \
    --header "Select context:" \
    --header.foreground="15" \
    --header.bold \
    --prompt.foreground="15" \
    --text.foreground="15" \
    --cursor-text.foreground="10" \
    --cursor-text.bold \
    --match.foreground="13" \
    --indicator.foreground="10" \
    --placeholder.foreground="7")

  # Handle cancel (Ctrl+C or empty selection)
  if [[ -z "$selected" ]]; then
    gum style --foreground 214 "Cancelled"
    return 0
  fi

  # Remove the checkmark suffix if present
  selected="${selected% âœ“}"

  echo ""
  gum style --foreground 212 "Switching to: $selected"
  echo ""

  # 5. Switch context if different from current
  if [[ "$selected" != "$current" ]]; then
    if ! kubectl config use-context "$selected" &>/dev/null; then
      gum style --foreground 196 "âœ— Failed to switch to $selected"
      return 1
    fi
  fi

  # 6. Prompt for namespace - try to fetch from cluster first
  local ns=""
  local namespaces

  if namespaces=$(timeout 5 kubectl get namespaces -o jsonpath='{.items[*].metadata.name}' 2>/dev/null); then
    # Convert space-separated to newline-separated and filter
    ns=$(echo "$namespaces" | tr ' ' '\n' | gum filter \
      --indicator="â†’" \
      --reverse \
      --header "Select namespace:" \
      --placeholder "Type to filter..." \
      --header.foreground="15" \
      --header.bold \
      --prompt.foreground="15" \
      --text.foreground="15" \
      --cursor-text.foreground="10" \
      --cursor-text.bold \
      --match.foreground="13" \
      --indicator.foreground="10" \
      --placeholder.foreground="7")
  else
    gum style --foreground 214 "Could not fetch namespaces (timeout or error)"
    ns=$(gum input \
      --placeholder "Namespace (empty to skip)" \
      --header "Enter namespace manually:")
  fi

  if [[ -n "$ns" ]]; then
    if ! kubectl config set-context --current --namespace="$ns" &>/dev/null; then
      gum style --foreground 196 "âœ— Failed to set namespace $ns"
      return 1
    fi
  fi

  # 7. Show success message
  echo ""
  if [[ -n "$ns" ]]; then
    gum style \
      --border rounded \
      --border-foreground 82 \
      --foreground 82 \
      --padding "0 1" \
      "âœ“ Switched to $selected" \
      "  Namespace: $ns"
  else
    gum style \
      --border rounded \
      --border-foreground 82 \
      --foreground 82 \
      --padding "0 1" \
      "âœ“ Switched to $selected"
  fi
}

# Activate a Python virtualenv by searching upwards
activate_venv() {
  local venv_name="${1:-.venv}"
  local start_dir="$PWD"
  local dir="$PWD"

  # Abort if any virtualenv is already active
  if [[ -n "$VIRTUAL_ENV" ]]; then
    echo "A venv is already activated at: $VIRTUAL_ENV"
    return 0
  fi

  while [[ "$dir" != "/" ]]; do
    if [[ -d "$dir/$venv_name" && -f "$dir/$venv_name/bin/activate" ]]; then
      # Found in current directory â†’ activate without confirmation
      if [[ "$dir" == "$start_dir" ]]; then
        source "$dir/$venv_name/bin/activate"
        return 0
      fi

      # Found in parent directory â†’ ask for confirmation (YES is default)
      print -n "Found virtualenv at '$dir/$venv_name'. Activate it? [Y/n] "
      read -r reply
      reply="${reply:-Y}"

      if [[ "$reply" =~ ^[Yy]$ ]]; then
        source "$dir/$venv_name/bin/activate"
        return 0
      else
        echo "Activation cancelled."
        return 1
      fi
    fi

    dir="${dir:h}"
  done

  echo "No virtualenv '$venv_name' found in current or parent directories."
  return 1
}
